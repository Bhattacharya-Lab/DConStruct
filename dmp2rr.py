#!/usr/bin/python

#  DConStruct: Hybridized Distance- and Contact-based Hierarchical Structure Modeling for Folding Soluble and Membrane Proteins
#
#  Copyright (C) Bhattacharya Laboratory 2019
#
#  DConStruct is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  DConStruct is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with DConStruct.  If not, see <http://www.gnu.org/licenses/>.
#
######################################################################################################################################################################################################
# this program generates distance/contact map (rr) file from distance map histogram (distogram) rawdistpred.current generated by DMPfold with user defined threshold and top contact selection cutoffs
######################################################################################################################################################################################################

import operator
import os
import math
import sys
import optparse    # for option sorting
import random
from decimal import *
getcontext().prec = 4
parser = optparse.OptionParser()
parser.add_option('-d', dest='dist',
        default = '',    # default empty
        help = 'name of raw distance map (DMPfold distogram)')
parser.add_option('-a', dest='fasta',
        default = '',    # default empty
        help = 'name of fasta file')

parser.add_option('-t', dest='threshold',
        default = '12',    # default 12
        help = 'distance threshold (for contact conversion)')

parser.add_option('-r', dest='rr',
        default = 'out',    # default out
        help = 'name of output distance/contact map')
parser.add_option('-c', dest='c',
        default = '0',    # default 0
        help = '0 for 3 class distance conversion and 1 for contact conversion')

(options,args) = parser.parse_args()
dist = options.dist
fasta = options.fasta
threshold = options.threshold
rr = options.rr
c = options.c
try:
        ffasta = open(fasta, 'r')
        flines = ffasta.readlines()
except IOError:
        sys.exit()
        print ('skipping..')

frr = open(rr, 'w')
frr.write(flines[1].strip())
frr.write('\n')



try:
        f = open(dist, 'r')
        lines = f.readlines()
        rrList = []
        for line in lines:
                line = line.split()

                try:
                        res1 = int(line[0])
                        res2 = int(line[1])
                except ValueError:
                        print ('value error..')
                        continue

                count = 0
                for i in range(2, int(threshold)+2):
			th = i
                        count += (float(line[i])) #Decimal(float(line[i]))
			if (count >= 0.85):
				
				break
			
					
		if (th <= 9):
			th = 8
		elif (th > 9 and th <= 11):
			th = 10
		elif (th > 11 and th <= 13):
			th = 12
		if (count < 0.0001):
                        count = 0.0001
		if (c == '0'):
			th = threshold
                rrList.append([str(res1), str(res2), str(th), str(count)])
        f.close()
        dict1 = {}
        for x in rrList:
                dict1[(x[0], x[1], x[2])] = x[3]
        sorted_rr = sorted(dict1.items(), key=operator.itemgetter(1))
        sorted_rr.reverse()
        count = 0
        for sr in sorted_rr:
                (i, j, th), p = sr[0], sr[1]

                frr.write(str(i))
                frr.write(' ')
                frr.write(str(j))
                frr.write(' ')
                frr.write('0')
                frr.write(' ')
                frr.write(th)
                frr.write(' ')
                frr.write(str(p))
                frr.write('\n')
                count += 1
except IOError:

        print ('skippig..')


ffasta.close()
frr.close()
